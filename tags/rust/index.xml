<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on Immunant, Inc</title>
    <link>/tags/rust/</link>
    <description>Recent content in Rust on Immunant, Inc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Immunant, Inc.</copyright>
    <lastBuildDate>Wed, 18 Dec 2019 16:00:00 -0800</lastBuildDate>
    
	<atom:link href="/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Source Code Linking: Merging C Headers into Rust Modules</title>
      <link>/blog/2019/12/header_merging/</link>
      <pubDate>Wed, 18 Dec 2019 16:00:00 -0800</pubDate>
      
      <guid>/blog/2019/12/header_merging/</guid>
      <description>Producing readable, idiomatic Rust code is a major goal of C2Rust, our project to accelerate migration of C code into Rust. One hurdle we faced is the mismatch between C headers and the Rust module system. C and Rust are similar in many ways: they&#39;re both performance oriented languages with explicit memory management and full control over every aspect of the system. Rust&#39;s module system is a huge improvement over C header files.</description>
    </item>
    
    <item>
      <title>Rust 2020: Lessons learned by transpiling C to Rust</title>
      <link>/blog/2019/11/rust2020/</link>
      <pubDate>Tue, 12 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/11/rust2020/</guid>
      <description>The C2Rust project is all about translating C code into an equivalent, drop-in ABI-compatible Rust implementation. (Read our C2Rust introductory blog post here.) Along the way we&#39;ve uncovered some dark corners of C as it&#39;s written in practice, and found places where Rust can&#39;t quite replicate the same code with the same ABI. This is the story of those dark corners and the areas we think Rust needs to improve to be fully FFI compatible with C.</description>
    </item>
    
    <item>
      <title>Improved C Variadics in Rust and C2Rust</title>
      <link>/blog/2019/09/variadics/</link>
      <pubDate>Tue, 17 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/09/variadics/</guid>
      <description>Introduction to C Variadics The C language provides a special class of functions called variadic functions that can be called with a variable number of arguments. The declaration of a variadic function ends with an ellipsis, e.g.:
void variadic_function(int x, ...);  Variadic functions can be called with any number of arguments in place of the ellipsis (including none at all).
The C runtime provides a set of helper macros that developers use to retrieve the values of the variadic arguments.</description>
    </item>
    
    <item>
      <title>Introduction to C2Rust</title>
      <link>/blog/2019/08/introduction-to-c2rust/</link>
      <pubDate>Fri, 16 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/2019/08/introduction-to-c2rust/</guid>
      <description>We believe that software should be both fast and safe. Languages like C and C++ deliver blazingly fast performance but are pretty much impossible to use safely. Software mitigations built into the operating system make exploitation of buggy code much harder but attackers are amazing at finding ways to bypass new defenses. What we really need is a way to eliminate the source of memory corruption bugs. Rust delivers on speed and interoperability while making memory safety the default.</description>
    </item>
    
  </channel>
</rss>